const chalk = require('chalk');
const glob = require("glob");
const fs = require('fs');

/**
 * The file header for messages files.
 */
const FILE_HEADER = `/**
* Message translations.
*
* This file is automatically generated by the 'yarn run translations extract'
* command. It contains the localizable messages extracted from source code.
*
* You may modify this file by translating the extracted messages.
*
* Each object element represents the translation (value) of a message (key).
* If the value is empty, the message is considered as not translated.
*
* Messages that no longer need translation will have their translations
* enclosed between a pair of '@@' marks.
*
* Message string can be used with plural forms format. Check the documentation
* for details.
*
* NOTE: this file must be saved in UTF-8 encoding.
*/
module.exports = `;

/**
 * Extractor class
 * 
 * @todo Also generate the index.js file in languages directory
 */
var Extractor = function(config) {

  this.config = config;

  this.verbose = typeof config.verbose !== 'undefined' ? !!config.verbose : false;

  if (!this.directoryExists(this.config.messagePath)) {
    this.fatal(`The directory ${chalk.green(this.config.messagePath)} does not exist.`);
  }

};

/**
 * Extractor methods
 */
Extractor.prototype = {
  /**
   * Tells if a directory exists
   * 
   * @param {string} directory The tested directory
   */
  directoryExists(directory) {
    try {
      fs.statSync(directory);
      return true;
    } catch (e) { }
    return false;
  },

  /**
   * Logs an error message and exits the current process
   * 
   * @param {string} message The error message
   */
  fatal(message) {
    console.error(`${chalk.red("error")} ${message}`);
   // process.exit(1);
  },

  /**
   * Prints a message, if in verbose mode
   * 
   * @param {*} message The message
   */
  report(message) {
    if (this.verbose) {
      console.log(message);      
    }
  },

  /**
   * Scans the source file and extracts messages to be translated
   */
  extractFromSource() {

    // TODO: Handle \' \" in messages
    const r = /\Wt\(('|")(.*?)\1/g;

    let messages = {};

    this.config.sourcePath.forEach(function (source) {
      let files = glob.sync(source + "/**/*.js", { debug: false });
      
      files.forEach(function (file) {

        for (let i = 0; i < this.config.ignorePath.length; i++) {
         // console.log(file, this.config.ignorePath[i]);
          if (file.indexOf(this.config.ignorePath[i]) !== -1) {
            return;
          }
        }

        //console.log(file);
        let contents = fs.readFileSync(file).toString();
        let counter = 0;
        let matches = false;
        while (matches = r.exec(contents)) {
          if (typeof messages[matches[2]] === "undefined") {
            counter++;
          }
          messages[matches[2]] = '';
        }
        this.report(` - parsing ${chalk.bold(file)} .. ${chalk.bold(counter)} strings found!\n`);
      }.bind(this));
    }.bind(this));

    return messages;
  },

  /**
   * 
   * @param {*} messages 
   */
  generateFiles(messages) {

    this.report("Generating translations:");

    this.config.languages.forEach(function (language) {
      let filepath = this.config.messagePath + '/' + language + '.js';
      
      let oldMessages = {};
      try {
        oldMessages = require(filepath);        
      } catch (e) {

      }

      let action = oldMessages && oldMessages.length === 0 ? "generated" : "merged";
      
      // Get a fresh copy of found strings
      var newMessages = messages;

      // Iterate on old strings
      Object.keys(oldMessages).forEach(function (key) {
        if (typeof newMessages[key] !== "undefined") {
          // Translation needed & found: copy it
          newMessages[key] = oldMessages[key];
        } else {
          // Translation old & gone: surround it with @
          newMessages[key] = '@' + oldMessages[key].replace(/^@+|@+$/g, '') + '@';
        }
      });

      // Write the new message file
      fs.writeFile(filepath, FILE_HEADER + JSON.stringify(newMessages, null, 2) + ';', 'utf8', function (err) {
        if (err) throw err;
      });
      this.report(` - ${action} ${chalk.bold(filepath)}`);
    }.bind(this));
  },

  /**
   * Extracts messages to be translated from the source code
   * 
   * @return {boolean} TRUE on success
   */
  extractMessages() {
    this.report(`Extracting messages in ${chalk.green(this.config.sourcePath)} using ${chalk.green(this.config.translator + '()')}`);

    let messages = this.extractFromSource();
    this.report("Done parsing\n");

    this.generateFiles(messages);
    this.report("Done, have fun translating!\n"); // Et voilÃ !

    return true;
  }

}

module.exports = Extractor;
